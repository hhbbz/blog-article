---
title: Mysql死锁的产生和解决
date: 2017-11-29 23:11:33
updated: 2017-11-30 09:58:54
categories: 
- 后端
tags:
- Mysql
---

# 产生死锁的四个必要条件：

1. 互斥条件：一个资源每次只能被一个进程使用。
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。
下列方法有助于最大限度地降低死锁：

1. 按同一顺序访问对象。
2. 避免事务中的用户交互。
3. 保持事务简短并在一个批处理中。
4. 使用低隔离级别。
5. 使用绑定连接。

# 数据库常见死锁原因及处理

1. 事务之间对资源访问顺序的交替

**出现原因：**
一个用户A 访问表A（锁住了表A），然后又访问表B；另一个用户B 访问表B（锁住了表B），然后企图访问表A；这时用户A由于用户B已经锁住表B，它必须等待用户B释放表B才能继续，同样用户B要等用户A释放表A才能继续，这就死锁就产生了。

**解决方法：**
这种死锁比较常见，是由于程序的BUG产生的

2. 并发修改同一记录

**出现原因：**
用户A查询一条纪录，然后修改该条纪录；这时用户B修改该条纪录，这时用户A的事务里锁的性质由查询的共享锁企图上升到独占锁，而用户B里的独占锁由于A有共享锁存在所以必须等A释放掉共享锁，而A由于B的独占锁而无法上升的独占锁也就不可能释放共享锁，于是出现了死锁。这种死锁由于比较隐蔽，但在稍大点的项目中经常发生。

**解决方法：**

1. 使用乐观锁进行控制。(cas:预期值，内存值，新值)
2. 使用悲观锁进行控制。(mysql:setAutoCommit=0，select...for update)
